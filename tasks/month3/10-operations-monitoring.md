# Task: BLEAé‹ç”¨ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰ã¨ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£é‹ç”¨æœ€é©åŒ–

**å®Ÿæ–½æœŸé–“**: Month 3 Week 3 (Day 1-2)  
**æ¨å®šå·¥æ•°**: 8æ™‚é–“  
**å„ªå…ˆåº¦**: é«˜  

## æ¦‚è¦

BLEAçµ±åˆé‹ç”¨ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰ã®æ§‹ç¯‰ã‚’å®Œäº†ã—ã€ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£é‹ç”¨ãƒ—ãƒ­ã‚»ã‚¹ã€ã‚¤ãƒ³ã‚·ãƒ‡ãƒ³ãƒˆå¯¾å¿œãƒ•ãƒ­ãƒ¼ã€è‡ªå‹•åŒ–ã•ã‚ŒãŸé‹ç”¨ç›£è¦–ã‚·ã‚¹ãƒ†ãƒ ã‚’ç¢ºç«‹ã™ã‚‹ã€‚

## å­¦ç¿’ç›®æ¨™

- åŒ…æ‹¬çš„é‹ç”¨ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰ã®æ§‹ç¯‰
- ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚¤ãƒ³ã‚·ãƒ‡ãƒ³ãƒˆå¯¾å¿œã®è‡ªå‹•åŒ–
- é‹ç”¨åŠ¹ç‡åŒ–ã¨ã‚³ã‚¹ãƒˆæœ€é©åŒ–
- BLEAæº–æ‹ ã®é‹ç”¨ãƒ—ãƒ­ã‚»ã‚¹ç¢ºç«‹

## å‰ææ¡ä»¶

- æœ¬ç•ªç’°å¢ƒãƒ‡ãƒ—ãƒ­ã‚¤å®Œäº†
- ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆå®Œäº†
- å…¨ã‚·ã‚¹ãƒ†ãƒ æ©Ÿèƒ½ãŒæ­£å¸¸ç¨¼åƒ

## ã‚¿ã‚¹ã‚¯è©³ç´°

### Day 1: çµ±åˆé‹ç”¨ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰æ§‹ç¯‰

#### 1. BLEAçµ±åˆãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰è¨­è¨ˆ (4æ™‚é–“)
- [ ] é‹ç”¨ãƒ¡ãƒˆãƒªã‚¯ã‚¹è¨­è¨ˆ
- [ ] ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ç›£è¦–ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰
- [ ] ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ç›£è¦–çµ±åˆ
- [ ] ã‚³ã‚¹ãƒˆç›£è¦–ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰

#### 2. CloudWatchçµ±åˆæœ€é©åŒ– (2æ™‚é–“)
- [ ] ã‚«ã‚¹ã‚¿ãƒ ãƒ¡ãƒˆãƒªã‚¯ã‚¹å®Ÿè£…
- [ ] ãƒ­ã‚°è§£æå¼·åŒ–
- [ ] ã‚¢ãƒ©ãƒ¼ãƒˆæœ€é©åŒ–
- [ ] è‡ªå‹•å¯¾å¿œè¨­å®š

#### 3. é‹ç”¨åŠ¹ç‡åŒ–æ©Ÿèƒ½å®Ÿè£… (2æ™‚é–“)
- [ ] è‡ªå‹•ã‚¹ã‚±ãƒ¼ãƒªãƒ³ã‚°æœ€é©åŒ–
- [ ] ãƒªã‚½ãƒ¼ã‚¹ä½¿ç”¨ç‡ç›£è¦–
- [ ] äºˆé˜²ä¿å®ˆã‚¢ãƒ©ãƒ¼ãƒˆ
- [ ] ãƒ¬ãƒãƒ¼ãƒˆè‡ªå‹•ç”Ÿæˆ

### Day 2: ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£é‹ç”¨ã¨ãƒ—ãƒ­ã‚»ã‚¹ç¢ºç«‹

#### 1. ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£é‹ç”¨ãƒ—ãƒ­ã‚»ã‚¹ (4æ™‚é–“)
- [ ] ã‚¤ãƒ³ã‚·ãƒ‡ãƒ³ãƒˆå¯¾å¿œãƒ—ãƒ­ã‚»ã‚¹
- [ ] è„…å¨ãƒãƒ³ãƒ†ã‚£ãƒ³ã‚°è‡ªå‹•åŒ–
- [ ] è„†å¼±æ€§ç®¡ç†ãƒ—ãƒ­ã‚»ã‚¹
- [ ] ã‚³ãƒ³ãƒ—ãƒ©ã‚¤ã‚¢ãƒ³ã‚¹ç¶™ç¶šç›£è¦–

#### 2. è‡ªå‹•å¯¾å¿œã‚·ã‚¹ãƒ†ãƒ å¼·åŒ– (2æ™‚é–“)
- [ ] è‡ªå‹•éš”é›¢æ©Ÿèƒ½
- [ ] è‡ªå‹•é€šçŸ¥ã‚¨ã‚¹ã‚«ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
- [ ] è‡ªå‹•ä¿®å¾©æ©Ÿèƒ½
- [ ] ãƒ­ã‚°åˆ†æè‡ªå‹•åŒ–

#### 3. é‹ç”¨ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆæ•´å‚™ (2æ™‚é–“)
- [ ] é‹ç”¨æ‰‹é †æ›¸æ›´æ–°
- [ ] ã‚¤ãƒ³ã‚·ãƒ‡ãƒ³ãƒˆå¯¾å¿œæ‰‹é †
- [ ] é‹ç”¨ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ
- [ ] ç½å®³å¾©æ—§æ‰‹é †

### MCP ã‚µãƒ¼ãƒæ´»ç”¨

```
ğŸ’¬ "BLEAçµ±åˆç’°å¢ƒã§ã®é‹ç”¨ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰ã¨ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£é‹ç”¨ãƒ—ãƒ­ã‚»ã‚¹ã‚’æ§‹ç¯‰ã—ã¦ãã ã•ã„ã€‚
è‡ªå‹•åŒ–ã•ã‚ŒãŸã‚¤ãƒ³ã‚·ãƒ‡ãƒ³ãƒˆå¯¾å¿œã€è„…å¨æ¤œçŸ¥ã€ç¶™ç¶šçš„ãªã‚³ãƒ³ãƒ—ãƒ©ã‚¤ã‚¢ãƒ³ã‚¹ç›£è¦–ã‚’å«ã‚ã¦ãã ã•ã„ã€‚"
```

## æˆæœç‰©

### 1. çµ±åˆé‹ç”¨ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰

```typescript
// lib/monitoring/operations-dashboard-stack.ts
export class OperationsDashboardStack extends cdk.Stack {
  constructor(scope: Construct, id: string, props: OperationsDashboardStackProps) {
    super(scope, id, props);

    // ãƒ¡ã‚¤ãƒ³ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰
    const mainDashboard = new cloudwatch.Dashboard(this, 'ChatApp-Operations-Dashboard', {
      dashboardName: 'ChatApp-BLEA-Operations',
      widgets: [
        // ã‚·ã‚¹ãƒ†ãƒ å…¨ä½“æ¦‚è¦
        [
          this.createSystemOverviewWidget(),
          this.createSecurityOverviewWidget()
        ],
        
        // ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ãƒ¡ãƒˆãƒªã‚¯ã‚¹
        [
          this.createApplicationMetricsWidget(props),
          this.createPerformanceMetricsWidget(props)
        ],
        
        // BLEA ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ¡ãƒˆãƒªã‚¯ã‚¹
        [
          this.createBLEASecurityWidget(),
          this.createComplianceWidget()
        ],
        
        // ã‚¤ãƒ³ãƒ•ãƒ©ã‚¹ãƒˆãƒ©ã‚¯ãƒãƒ£ç›£è¦–
        [
          this.createInfrastructureWidget(props),
          this.createCostOptimizationWidget()
        ],
        
        // ã‚¢ãƒ©ãƒ¼ãƒˆã¨é€šçŸ¥
        [
          this.createActiveAlertsWidget(),
          this.createRecentIncidentsWidget()
        ]
      ]
    });

    // ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£å°‚ç”¨ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰
    const securityDashboard = new cloudwatch.Dashboard(this, 'Security-Dashboard', {
      dashboardName: 'ChatApp-Security-Operations',
      widgets: [
        [this.createThreatDetectionWidget()],
        [this.createSecurityEventsWidget()],
        [this.createVulnerabilityWidget()],
        [this.createAccessAnalyticsWidget()],
        [this.createSecurityHubFindingsWidget()],
        [this.createGuardDutyFindingsWidget()]
      ]
    });

    // è‡ªå‹•é€šçŸ¥ã‚·ã‚¹ãƒ†ãƒ 
    this.setupAutomatedNotifications(props);
    
    // è‡ªå‹•å¯¾å¿œã‚·ã‚¹ãƒ†ãƒ 
    this.setupAutomatedResponse(props);
  }

  private createSystemOverviewWidget(): cloudwatch.IWidget {
    return new cloudwatch.SingleValueWidget({
      title: 'System Health Overview',
      metrics: [
        new cloudwatch.MathExpression({
          expression: 'IF(api_errors < 10 AND db_connections < 80 AND lambda_errors < 5, 100, 0)',
          usingMetrics: {
            api_errors: new cloudwatch.Metric({
              namespace: 'AWS/ApiGateway',
              metricName: '4XXError',
              statistic: 'Sum'
            }),
            db_connections: new cloudwatch.Metric({
              namespace: 'AWS/RDS',
              metricName: 'DatabaseConnections',
              statistic: 'Average'
            }),
            lambda_errors: new cloudwatch.Metric({
              namespace: 'AWS/Lambda',
              metricName: 'Errors',
              statistic: 'Sum'
            })
          },
          label: 'Overall Health (%)',
          period: cdk.Duration.minutes(5)
        })
      ],
      width: 6,
      height: 3
    });
  }

  private createSecurityOverviewWidget(): cloudwatch.IWidget {
    return new cloudwatch.GraphWidget({
      title: 'Security Events & Threats',
      left: [
        new cloudwatch.Metric({
          namespace: 'AWS/WAF',
          metricName: 'BlockedRequests',
          statistic: 'Sum',
          label: 'WAF Blocked Requests'
        }),
        new cloudwatch.Metric({
          namespace: 'AWS/GuardDuty',
          metricName: 'FindingCount',
          statistic: 'Sum',
          label: 'GuardDuty Findings'
        })
      ],
      right: [
        new cloudwatch.Metric({
          namespace: 'ChatApp/Security',
          metricName: 'SecurityEvents',
          statistic: 'Sum',
          label: 'Custom Security Events'
        })
      ],
      width: 6,
      height: 6
    });
  }

  private createBLEASecurityWidget(): cloudwatch.IWidget {
    return new cloudwatch.GraphWidget({
      title: 'BLEA Security Compliance',
      left: [
        new cloudwatch.Metric({
          namespace: 'AWS/Config',
          metricName: 'ComplianceByConfigRule',
          statistic: 'Average',
          label: 'Config Rules Compliance'
        }),
        new cloudwatch.Metric({
          namespace: 'AWS/SecurityHub',
          metricName: 'Findings',
          statistic: 'Sum',
          label: 'Security Hub Findings'
        })
      ],
      width: 12,
      height: 6
    });
  }

  private setupAutomatedNotifications(props: OperationsDashboardStackProps) {
    // é‡è¦åº¦åˆ¥é€šçŸ¥è¨­å®š
    const criticalTopic = new sns.Topic(this, 'CriticalAlerts', {
      topicName: 'ChatApp-Critical-Alerts',
      displayName: 'ChatApp Critical Alerts'
    });

    const warningTopic = new sns.Topic(this, 'WarningAlerts', {
      topicName: 'ChatApp-Warning-Alerts',
      displayName: 'ChatApp Warning Alerts'
    });

    // Slackçµ±åˆ
    new chatbot.SlackChannelConfiguration(this, 'CriticalSlackNotifications', {
      slackChannelConfigurationName: 'chatapp-critical-alerts',
      slackWorkspaceId: props.slackWorkspaceId,
      slackChannelId: props.criticalChannelId,
      notificationTopics: [criticalTopic],
      role: this.createChatbotRole()
    });

    // ãƒ¡ãƒ¼ãƒ«é€šçŸ¥
    criticalTopic.addSubscription(new subscriptions.EmailSubscription(props.emergencyEmail));
    warningTopic.addSubscription(new subscriptions.EmailSubscription(props.operationsEmail));

    // PagerDutyçµ±åˆï¼ˆé‡è¦ã‚¢ãƒ©ãƒ¼ãƒˆï¼‰
    if (props.pagerDutyEndpoint) {
      criticalTopic.addSubscription(
        new subscriptions.UrlSubscription(props.pagerDutyEndpoint)
      );
    }
  }

  private setupAutomatedResponse(props: OperationsDashboardStackProps) {
    // è‡ªå‹•å¯¾å¿œLambda
    const responseHandler = new lambda.Function(this, 'AutomatedResponseHandler', {
      runtime: lambda.Runtime.PYTHON_3_11,
      handler: 'response_handler.lambda_handler',
      code: lambda.Code.fromAsset('backend/automated-response'),
      environment: {
        QUARANTINE_BUCKET: props.quarantineBucket?.bucketName || '',
        SECURITY_HUB_REGION: this.region,
        SLACK_WEBHOOK_URL: props.slackWebhookUrl || '',
        AUTO_REMEDIATION_ENABLED: 'true'
      },
      timeout: cdk.Duration.minutes(5),
      memorySize: 512
    });

    // EventBridge ãƒ«ãƒ¼ãƒ«è¨­å®š
    const securityEventRule = new events.Rule(this, 'SecurityEventRule', {
      eventPattern: {
        source: ['aws.securityhub', 'aws.guardduty', 'chatapp.security'],
        detailType: ['Security Hub Findings', 'GuardDuty Finding', 'Custom Security Event'],
        detail: {
          severity: ['HIGH', 'CRITICAL']
        }
      }
    });

    securityEventRule.addTarget(new targets.LambdaFunction(responseHandler));

    // Configéæº–æ‹ å¯¾å¿œ
    const configNonComplianceRule = new events.Rule(this, 'ConfigNonComplianceRule', {
      eventPattern: {
        source: ['aws.config'],
        detailType: ['Config Rules Compliance Change'],
        detail: {
          newEvaluationResult: {
            complianceType: ['NON_COMPLIANT']
          }
        }
      }
    });

    configNonComplianceRule.addTarget(new targets.LambdaFunction(responseHandler));
  }

  private createChatbotRole(): iam.Role {
    return new iam.Role(this, 'ChatbotRole', {
      assumedBy: new iam.ServicePrincipal('chatbot.amazonaws.com'),
      managedPolicies: [
        iam.ManagedPolicy.fromAwsManagedPolicyName('CloudWatchReadOnlyAccess'),
        iam.ManagedPolicy.fromAwsManagedPolicyName('AWSSupportAccess')
      ]
    });
  }
}
```

### 2. è‡ªå‹•å¯¾å¿œã‚·ã‚¹ãƒ†ãƒ 

```python
# backend/automated-response/response_handler.py
"""
BLEAçµ±åˆè‡ªå‹•å¯¾å¿œã‚·ã‚¹ãƒ†ãƒ 
"""

import json
import boto3
import os
import logging
from datetime import datetime
from typing import Dict, Any, List
from enum import Enum

# ãƒ­ã‚°è¨­å®š
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class SeverityLevel(Enum):
    LOW = "LOW"
    MEDIUM = "MEDIUM" 
    HIGH = "HIGH"
    CRITICAL = "CRITICAL"

class ResponseAction(Enum):
    NOTIFY = "notify"
    ISOLATE = "isolate"
    BLOCK = "block"
    REMEDIATE = "remediate"
    ESCALATE = "escalate"

class AutomatedResponseHandler:
    def __init__(self):
        self.region = os.environ.get('AWS_REGION', 'ap-northeast-1')
        self.security_hub = boto3.client('securityhub', region_name=self.region)
        self.ec2 = boto3.client('ec2', region_name=self.region)
        self.waf = boto3.client('wafv2', region_name=self.region)
        self.s3 = boto3.client('s3')
        self.sns = boto3.client('sns')
        
        self.quarantine_bucket = os.environ.get('QUARANTINE_BUCKET')
        self.slack_webhook = os.environ.get('SLACK_WEBHOOK_URL')
        self.auto_remediation_enabled = os.environ.get('AUTO_REMEDIATION_ENABLED', 'false').lower() == 'true'
        
    def lambda_handler(self, event: Dict[str, Any], context) -> Dict[str, Any]:
        """
        è‡ªå‹•å¯¾å¿œãƒ¡ã‚¤ãƒ³ãƒãƒ³ãƒ‰ãƒ©ãƒ¼
        """
        try:
            logger.info(f"Processing security event: {json.dumps(event, default=str)}")
            
            # ã‚¤ãƒ™ãƒ³ãƒˆè§£æ
            event_details = self.parse_security_event(event)
            
            if not event_details:
                logger.warning("Unable to parse security event")
                return {'statusCode': 400, 'body': 'Invalid event format'}
            
            # å¯¾å¿œã‚¢ã‚¯ã‚·ãƒ§ãƒ³æ±ºå®š
            actions = self.determine_response_actions(event_details)
            
            # è‡ªå‹•å¯¾å¿œå®Ÿè¡Œ
            response_results = []
            for action in actions:
                result = self.execute_response_action(action, event_details)
                response_results.append(result)
            
            # çµæœé€šçŸ¥
            self.send_response_notification(event_details, response_results)
            
            return {
                'statusCode': 200,
                'body': json.dumps({
                    'event_id': event_details.get('event_id'),
                    'actions_taken': len(response_results),
                    'results': response_results
                })
            }
            
        except Exception as e:
            logger.error(f"Error in automated response: {str(e)}")
            return {'statusCode': 500, 'body': f'Error: {str(e)}'}
    
    def parse_security_event(self, event: Dict[str, Any]) -> Dict[str, Any]:
        """ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚¤ãƒ™ãƒ³ãƒˆè§£æ"""
        detail = event.get('detail', {})
        source = event.get('source')
        
        # Security Hub ã‚¤ãƒ™ãƒ³ãƒˆ
        if source == 'aws.securityhub':
            return {
                'event_id': detail.get('id'),
                'severity': detail.get('severity', {}).get('label', 'LOW'),
                'title': detail.get('title'),
                'description': detail.get('description'),
                'resources': detail.get('resources', []),
                'source': 'security-hub',
                'raw_event': event
            }
        
        # GuardDuty ã‚¤ãƒ™ãƒ³ãƒˆ
        elif source == 'aws.guardduty':
            return {
                'event_id': detail.get('id'),
                'severity': detail.get('severity'),
                'title': detail.get('title'),
                'description': detail.get('description'),
                'service': detail.get('service', {}),
                'source': 'guardduty',
                'raw_event': event
            }
        
        # ã‚«ã‚¹ã‚¿ãƒ ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚¤ãƒ™ãƒ³ãƒˆ
        elif source == 'chatapp.security':
            return {
                'event_id': detail.get('event_id'),
                'severity': detail.get('severity', 'LOW'),
                'event_type': detail.get('event_type'),
                'details': detail.get('event_details', {}),
                'source': 'custom',
                'raw_event': event
            }
        
        # Configéæº–æ‹ ã‚¤ãƒ™ãƒ³ãƒˆ
        elif source == 'aws.config':
            return {
                'event_id': detail.get('configRuleName'),
                'severity': 'MEDIUM',
                'title': f"Config Rule Non-Compliance: {detail.get('configRuleName')}",
                'description': f"Resource {detail.get('resourceId')} is non-compliant",
                'resource_id': detail.get('resourceId'),
                'resource_type': detail.get('resourceType'),
                'source': 'config',
                'raw_event': event
            }
        
        return None
    
    def determine_response_actions(self, event_details: Dict[str, Any]) -> List[ResponseAction]:
        """å¯¾å¿œã‚¢ã‚¯ã‚·ãƒ§ãƒ³æ±ºå®š"""
        severity = event_details.get('severity', 'LOW')
        source = event_details.get('source')
        event_type = event_details.get('event_type', '')
        
        actions = []
        
        # é‡è¦åº¦åˆ¥åŸºæœ¬ã‚¢ã‚¯ã‚·ãƒ§ãƒ³
        if severity in ['CRITICAL', 'HIGH']:
            actions.append(ResponseAction.NOTIFY)
            actions.append(ResponseAction.ESCALATE)
        elif severity == 'MEDIUM':
            actions.append(ResponseAction.NOTIFY)
        
        # ã‚¤ãƒ™ãƒ³ãƒˆç¨®åˆ¥åˆ¥ã‚¢ã‚¯ã‚·ãƒ§ãƒ³
        if 'malware' in event_type.lower() or 'virus' in event_type.lower():
            actions.extend([ResponseAction.ISOLATE, ResponseAction.REMEDIATE])
        
        if 'brute_force' in event_type.lower() or 'unauthorized_access' in event_type.lower():
            actions.extend([ResponseAction.BLOCK, ResponseAction.REMEDIATE])
        
        if source == 'config' and self.auto_remediation_enabled:
            actions.append(ResponseAction.REMEDIATE)
        
        return list(set(actions))  # é‡è¤‡å‰Šé™¤
    
    def execute_response_action(self, action: ResponseAction, event_details: Dict[str, Any]) -> Dict[str, Any]:
        """å€‹åˆ¥å¯¾å¿œã‚¢ã‚¯ã‚·ãƒ§ãƒ³å®Ÿè¡Œ"""
        action_result = {
            'action': action.value,
            'success': False,
            'message': '',
            'timestamp': datetime.utcnow().isoformat()
        }
        
        try:
            if action == ResponseAction.NOTIFY:
                action_result.update(self.send_notification(event_details))
            
            elif action == ResponseAction.ISOLATE:
                action_result.update(self.isolate_resource(event_details))
            
            elif action == ResponseAction.BLOCK:
                action_result.update(self.block_source(event_details))
            
            elif action == ResponseAction.REMEDIATE:
                action_result.update(self.auto_remediate(event_details))
            
            elif action == ResponseAction.ESCALATE:
                action_result.update(self.escalate_incident(event_details))
            
        except Exception as e:
            action_result['message'] = f"Action failed: {str(e)}"
            logger.error(f"Action {action.value} failed: {str(e)}")
        
        return action_result
    
    def send_notification(self, event_details: Dict[str, Any]) -> Dict[str, Any]:
        """é€šçŸ¥é€ä¿¡"""
        try:
            severity = event_details.get('severity', 'LOW')
            title = event_details.get('title', 'Security Event')
            
            # Slacké€šçŸ¥
            if self.slack_webhook:
                self.send_slack_notification(event_details)
            
            return {
                'success': True,
                'message': f'Notification sent for {severity} severity event'
            }
            
        except Exception as e:
            return {'success': False, 'message': str(e)}
    
    def isolate_resource(self, event_details: Dict[str, Any]) -> Dict[str, Any]:
        """ãƒªã‚½ãƒ¼ã‚¹éš”é›¢"""
        try:
            resources = event_details.get('resources', [])
            isolated_resources = []
            
            for resource in resources:
                resource_type = resource.get('Type', '')
                resource_id = resource.get('Id', '')
                
                if 'AwsEc2Instance' in resource_type:
                    # EC2ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹éš”é›¢
                    instance_id = resource_id.split('/')[-1]
                    self.isolate_ec2_instance(instance_id)
                    isolated_resources.append(instance_id)
                
                elif 'AwsS3Object' in resource_type:
                    # S3ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆéš”é›¢
                    self.quarantine_s3_object(resource_id)
                    isolated_resources.append(resource_id)
            
            return {
                'success': True,
                'message': f'Isolated {len(isolated_resources)} resources',
                'isolated_resources': isolated_resources
            }
            
        except Exception as e:
            return {'success': False, 'message': str(e)}
    
    def isolate_ec2_instance(self, instance_id: str):
        """EC2ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹éš”é›¢"""
        # éš”é›¢ç”¨ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚°ãƒ«ãƒ¼ãƒ—ä½œæˆ/å–å¾—
        isolation_sg = self.get_or_create_isolation_security_group()
        
        # ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚°ãƒ«ãƒ¼ãƒ—ã‚’éš”é›¢SGã«å¤‰æ›´
        self.ec2.modify_instance_attribute(
            InstanceId=instance_id,
            Groups=[isolation_sg]
        )
        
        # ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã«ã‚¿ã‚°è¿½åŠ 
        self.ec2.create_tags(
            Resources=[instance_id],
            Tags=[
                {'Key': 'SecurityStatus', 'Value': 'Isolated'},
                {'Key': 'IsolationTimestamp', 'Value': datetime.utcnow().isoformat()}
            ]
        )
    
    def quarantine_s3_object(self, object_arn: str):
        """S3ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆéš”é›¢"""
        if not self.quarantine_bucket:
            raise ValueError("Quarantine bucket not configured")
        
        # ARNã‹ã‚‰ãƒã‚±ãƒƒãƒˆåã¨ã‚­ãƒ¼ã‚’æŠ½å‡º
        parts = object_arn.replace('arn:aws:s3:::', '').split('/', 1)
        source_bucket = parts[0]
        object_key = parts[1] if len(parts) > 1 else ''
        
        # éš”é›¢ãƒã‚±ãƒƒãƒˆã«ã‚³ãƒ”ãƒ¼
        quarantine_key = f"quarantine/{datetime.utcnow().strftime('%Y/%m/%d')}/{object_key}"
        
        self.s3.copy_object(
            CopySource={'Bucket': source_bucket, 'Key': object_key},
            Bucket=self.quarantine_bucket,
            Key=quarantine_key,
            MetadataDirective='REPLACE',
            Metadata={
                'OriginalLocation': f"{source_bucket}/{object_key}",
                'QuarantineTimestamp': datetime.utcnow().isoformat(),
                'QuarantineReason': 'Security threat detected'
            }
        )
        
        # å…ƒã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å‰Šé™¤
        self.s3.delete_object(Bucket=source_bucket, Key=object_key)
    
    def block_source(self, event_details: Dict[str, Any]) -> Dict[str, Any]:
        """æ”»æ’ƒå…ƒãƒ–ãƒ­ãƒƒã‚¯"""
        try:
            # GuardDutyã‚¤ãƒ™ãƒ³ãƒˆã‹ã‚‰IPã‚¢ãƒ‰ãƒ¬ã‚¹æŠ½å‡º
            service_details = event_details.get('service', {})
            remote_ip = service_details.get('remoteIpDetails', {}).get('ipAddressV4')
            
            if remote_ip:
                # WAFã§IPã‚¢ãƒ‰ãƒ¬ã‚¹ãƒ–ãƒ­ãƒƒã‚¯
                self.add_ip_to_waf_blocklist(remote_ip)
                return {
                    'success': True,
                    'message': f'Blocked IP address: {remote_ip}'
                }
            
            return {
                'success': False,
                'message': 'No IP address found to block'
            }
            
        except Exception as e:
            return {'success': False, 'message': str(e)}
    
    def add_ip_to_waf_blocklist(self, ip_address: str):
        """WAF IPãƒ–ãƒ­ãƒƒã‚¯ãƒªã‚¹ãƒˆè¿½åŠ """
        # IPã‚»ãƒƒãƒˆæ›´æ–°ï¼ˆå®Ÿè£…ã¯ç’°å¢ƒã«å¿œã˜ã¦èª¿æ•´ï¼‰
        # ã“ã®ä¾‹ã§ã¯æ—¢å­˜ã®IPã‚»ãƒƒãƒˆã‚’æ›´æ–°
        ip_set_id = 'chatapp-blocked-ips'
        
        try:
            # æ—¢å­˜ã®IPã‚¢ãƒ‰ãƒ¬ã‚¹ä¸€è¦§å–å¾—
            response = self.waf.get_ip_set(
                Scope='CLOUDFRONT',
                Id=ip_set_id,
                Name='ChatApp-Blocked-IPs'
            )
            
            current_addresses = response['IPSet']['Addresses']
            
            # æ–°ã—ã„IPã‚¢ãƒ‰ãƒ¬ã‚¹è¿½åŠ 
            if f"{ip_address}/32" not in current_addresses:
                current_addresses.append(f"{ip_address}/32")
                
                # IPã‚»ãƒƒãƒˆæ›´æ–°
                self.waf.update_ip_set(
                    Scope='CLOUDFRONT',
                    Id=ip_set_id,
                    Name='ChatApp-Blocked-IPs',
                    Addresses=current_addresses,
                    LockToken=response['LockToken']
                )
                
        except self.waf.exceptions.WAFNonexistentItemException:
            logger.warning(f"IP set {ip_set_id} not found")
    
    def auto_remediate(self, event_details: Dict[str, Any]) -> Dict[str, Any]:
        """è‡ªå‹•ä¿®å¾©"""
        try:
            source = event_details.get('source')
            
            if source == 'config':
                return self.remediate_config_non_compliance(event_details)
            elif source == 'security-hub':
                return self.remediate_security_finding(event_details)
            
            return {
                'success': False,
                'message': f'No remediation available for source: {source}'
            }
            
        except Exception as e:
            return {'success': False, 'message': str(e)}
    
    def remediate_config_non_compliance(self, event_details: Dict[str, Any]) -> Dict[str, Any]:
        """Configéæº–æ‹ è‡ªå‹•ä¿®å¾©"""
        rule_name = event_details.get('event_id')
        resource_id = event_details.get('resource_id')
        resource_type = event_details.get('resource_type')
        
        remediation_actions = {
            's3-bucket-public-read-prohibited': self.remediate_s3_public_read,
            's3-bucket-public-write-prohibited': self.remediate_s3_public_write,
            'rds-storage-encrypted': self.remediate_rds_encryption
        }
        
        if rule_name in remediation_actions:
            remediation_actions[rule_name](resource_id)
            return {
                'success': True,
                'message': f'Remediated {rule_name} for resource {resource_id}'
            }
        
        return {
            'success': False,
            'message': f'No automated remediation available for rule: {rule_name}'
        }
    
    def escalate_incident(self, event_details: Dict[str, Any]) -> Dict[str, Any]:
        """ã‚¤ãƒ³ã‚·ãƒ‡ãƒ³ãƒˆã‚¨ã‚¹ã‚«ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³"""
        try:
            # Security Hubã«é«˜é‡è¦åº¦æ‰€è¦‹ã¨ã—ã¦è¨˜éŒ²
            finding_id = f"escalated-{datetime.utcnow().strftime('%Y%m%d%H%M%S')}"
            
            self.security_hub.batch_import_findings(
                Findings=[{
                    'SchemaVersion': '2018-10-08',
                    'Id': finding_id,
                    'ProductArn': f"arn:aws:securityhub:{self.region}::product/custom/chatapp-auto-response",
                    'GeneratorId': 'automated-response-system',
                    'AwsAccountId': boto3.Session().get_credentials().access_key.split(':')[4] if ':' in boto3.Session().get_credentials().access_key else '',
                    'CreatedAt': datetime.utcnow().isoformat() + 'Z',
                    'UpdatedAt': datetime.utcnow().isoformat() + 'Z',
                    'Severity': {'Label': 'HIGH'},
                    'Title': f"Escalated Security Incident: {event_details.get('title', 'Unknown')}",
                    'Description': f"Automated escalation of security incident: {event_details.get('description', 'No description')}",
                    'Types': ['Unusual Behaviors/Application'],
                    'WorkflowState': 'NEW',
                    'RecordState': 'ACTIVE'
                }]
            )
            
            return {
                'success': True,
                'message': f'Incident escalated with finding ID: {finding_id}'
            }
            
        except Exception as e:
            return {'success': False, 'message': str(e)}
    
    def send_slack_notification(self, event_details: Dict[str, Any]):
        """Slacké€šçŸ¥é€ä¿¡"""
        import requests
        
        severity = event_details.get('severity', 'LOW')
        title = event_details.get('title', 'Security Event')
        description = event_details.get('description', 'No description')
        
        # é‡è¦åº¦ã«å¿œã˜ãŸè‰²è¨­å®š
        color_map = {
            'CRITICAL': '#FF0000',
            'HIGH': '#FF6600',
            'MEDIUM': '#FFFF00',
            'LOW': '#00FF00'
        }
        
        payload = {
            'attachments': [{
                'color': color_map.get(severity, '#808080'),
                'title': f'ğŸš¨ {severity} Security Alert: {title}',
                'text': description,
                'fields': [
                    {
                        'title': 'Event ID',
                        'value': event_details.get('event_id', 'Unknown'),
                        'short': True
                    },
                    {
                        'title': 'Timestamp',
                        'value': datetime.utcnow().isoformat(),
                        'short': True
                    }
                ],
                'footer': 'ChatApp Security System',
                'ts': int(datetime.utcnow().timestamp())
            }]
        }
        
        requests.post(self.slack_webhook, json=payload)
    
    def send_response_notification(self, event_details: Dict[str, Any], results: List[Dict[str, Any]]):
        """å¯¾å¿œçµæœé€šçŸ¥"""
        if self.slack_webhook:
            successful_actions = [r for r in results if r['success']]
            failed_actions = [r for r in results if not r['success']]
            
            payload = {
                'attachments': [{
                    'color': '#00FF00' if not failed_actions else '#FF6600',
                    'title': 'ğŸ¤– Automated Response Summary',
                    'text': f"Event: {event_details.get('title', 'Security Event')}",
                    'fields': [
                        {
                            'title': 'Successful Actions',
                            'value': ', '.join([r['action'] for r in successful_actions]) or 'None',
                            'short': True
                        },
                        {
                            'title': 'Failed Actions', 
                            'value': ', '.join([r['action'] for r in failed_actions]) or 'None',
                            'short': True
                        }
                    ]
                }]
            }
            
            requests.post(self.slack_webhook, json=payload)
    
    def get_or_create_isolation_security_group(self) -> str:
        """éš”é›¢ç”¨ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚°ãƒ«ãƒ¼ãƒ—å–å¾—/ä½œæˆ"""
        try:
            # æ—¢å­˜ã®éš”é›¢SGã‚’æ¤œç´¢
            response = self.ec2.describe_security_groups(
                Filters=[
                    {'Name': 'group-name', 'Values': ['chatapp-isolation-sg']}
                ]
            )
            
            if response['SecurityGroups']:
                return response['SecurityGroups'][0]['GroupId']
            
            # éš”é›¢SGä½œæˆ
            vpc_response = self.ec2.describe_vpcs(
                Filters=[{'Name': 'tag:Name', 'Values': ['ChatApp-VPC']}]
            )
            
            if not vpc_response['Vpcs']:
                raise ValueError("ChatApp VPC not found")
            
            vpc_id = vpc_response['Vpcs'][0]['VpcId']
            
            sg_response = self.ec2.create_security_group(
                GroupName='chatapp-isolation-sg',
                Description='Security group for isolating compromised resources',
                VpcId=vpc_id
            )
            
            return sg_response['GroupId']
            
        except Exception as e:
            logger.error(f"Failed to get/create isolation security group: {str(e)}")
            raise

# Lambda ã‚¨ãƒ³ãƒˆãƒªãƒã‚¤ãƒ³ãƒˆ
def lambda_handler(event, context):
    handler = AutomatedResponseHandler()
    return handler.lambda_handler(event, context)
```

### 3. é‹ç”¨ãƒ¬ãƒãƒ¼ãƒˆè‡ªå‹•ç”Ÿæˆ

```python
# scripts/generate-operations-report.py
"""
BLEAçµ±åˆé‹ç”¨ãƒ¬ãƒãƒ¼ãƒˆè‡ªå‹•ç”Ÿæˆ
"""

import boto3
import json
from datetime import datetime, timedelta
import pandas as pd
from typing import Dict, List, Any
import argparse

class OperationsReportGenerator:
    def __init__(self, region='ap-northeast-1'):
        self.region = region
        self.cloudwatch = boto3.client('cloudwatch', region_name=region)
        self.security_hub = boto3.client('securityhub', region_name=region)
        self.config = boto3.client('config', region_name=region)
        self.cost_explorer = boto3.client('ce', region_name='us-east-1')  # Cost Explorer is global
        
    def generate_weekly_report(self) -> Dict[str, Any]:
        """é€±æ¬¡é‹ç”¨ãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆ"""
        end_time = datetime.utcnow()
        start_time = end_time - timedelta(days=7)
        
        report = {
            'report_period': {
                'start': start_time.isoformat(),
                'end': end_time.isoformat(),
                'duration_days': 7
            },
            'system_health': self.get_system_health_metrics(start_time, end_time),
            'security_summary': self.get_security_summary(start_time, end_time),
            'performance_metrics': self.get_performance_metrics(start_time, end_time),
            'compliance_status': self.get_compliance_status(),
            'cost_analysis': self.get_cost_analysis(start_time, end_time),
            'incidents': self.get_incident_summary(start_time, end_time),
            'recommendations': []
        }
        
        # æ¨å¥¨äº‹é …ç”Ÿæˆ
        report['recommendations'] = self.generate_recommendations(report)
        
        return report
    
    def get_system_health_metrics(self, start_time: datetime, end_time: datetime) -> Dict[str, Any]:
        """ã‚·ã‚¹ãƒ†ãƒ ãƒ˜ãƒ«ã‚¹ãƒ¡ãƒˆãƒªã‚¯ã‚¹å–å¾—"""
        try:
            # API Gateway ãƒ¡ãƒˆãƒªã‚¯ã‚¹
            api_metrics = self.cloudwatch.get_metric_statistics(
                Namespace='AWS/ApiGateway',
                MetricName='Count',
                Dimensions=[{'Name': 'ApiName', 'Value': 'ChatApp-API'}],
                StartTime=start_time,
                EndTime=end_time,
                Period=3600,
                Statistics=['Sum']
            )
            
            # Lambda ãƒ¡ãƒˆãƒªã‚¯ã‚¹
            lambda_metrics = self.cloudwatch.get_metric_statistics(
                Namespace='AWS/Lambda',
                MetricName='Invocations',
                StartTime=start_time,
                EndTime=end_time,
                Period=3600,
                Statistics=['Sum']
            )
            
            # RDS ãƒ¡ãƒˆãƒªã‚¯ã‚¹
            rds_metrics = self.cloudwatch.get_metric_statistics(
                Namespace='AWS/RDS',
                MetricName='CPUUtilization',
                Dimensions=[{'Name': 'DBClusterIdentifier', 'Value': 'chatapp-cluster'}],
                StartTime=start_time,
                EndTime=end_time,
                Period=3600,
                Statistics=['Average', 'Maximum']
            )
            
            total_api_requests = sum([point['Sum'] for point in api_metrics['Datapoints']])
            total_lambda_invocations = sum([point['Sum'] for point in lambda_metrics['Datapoints']])
            avg_cpu_utilization = sum([point['Average'] for point in rds_metrics['Datapoints']]) / len(rds_metrics['Datapoints']) if rds_metrics['Datapoints'] else 0
            
            return {
                'api_requests_total': total_api_requests,
                'lambda_invocations_total': total_lambda_invocations,
                'database_cpu_avg': round(avg_cpu_utilization, 2),
                'uptime_percentage': self.calculate_uptime(start_time, end_time),
                'availability_sla_met': avg_cpu_utilization < 80  # 80%æœªæº€ã‚’æ­£å¸¸ã¨ã™ã‚‹
            }
            
        except Exception as e:
            return {'error': str(e)}
    
    def get_security_summary(self, start_time: datetime, end_time: datetime) -> Dict[str, Any]:
        """ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚µãƒãƒªãƒ¼å–å¾—"""
        try:
            # Security Hub æ‰€è¦‹
            findings = self.security_hub.get_findings(
                Filters={
                    'CreatedAt': [
                        {
                            'Start': start_time,
                            'End': end_time
                        }
                    ],
                    'RecordState': [{'Value': 'ACTIVE', 'Comparison': 'EQUALS'}]
                },
                MaxResults=100
            )
            
            # é‡è¦åº¦åˆ¥é›†è¨ˆ
            severity_counts = {'CRITICAL': 0, 'HIGH': 0, 'MEDIUM': 0, 'LOW': 0}
            for finding in findings['Findings']:
                severity = finding['Severity']['Label']
                severity_counts[severity] = severity_counts.get(severity, 0) + 1
            
            # WAF ãƒ–ãƒ­ãƒƒã‚¯æ•°
            waf_metrics = self.cloudwatch.get_metric_statistics(
                Namespace='AWS/WAFV2',
                MetricName='BlockedRequests',
                StartTime=start_time,
                EndTime=end_time,
                Period=3600,
                Statistics=['Sum']
            )
            
            blocked_requests = sum([point['Sum'] for point in waf_metrics['Datapoints']])
            
            return {
                'total_findings': len(findings['Findings']),
                'findings_by_severity': severity_counts,
                'blocked_requests': blocked_requests,
                'new_vulnerabilities': len([f for f in findings['Findings'] if 'vulnerability' in f['Title'].lower()]),
                'resolved_findings': self.get_resolved_findings_count(start_time, end_time)
            }
            
        except Exception as e:
            return {'error': str(e)}
    
    def get_performance_metrics(self, start_time: datetime, end_time: datetime) -> Dict[str, Any]:
        """ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ¡ãƒˆãƒªã‚¯ã‚¹å–å¾—"""
        try:
            # API ãƒ¬ã‚¹ãƒãƒ³ã‚¹æ™‚é–“
            latency_metrics = self.cloudwatch.get_metric_statistics(
                Namespace='AWS/ApiGateway',
                MetricName='Latency',
                Dimensions=[{'Name': 'ApiName', 'Value': 'ChatApp-API'}],
                StartTime=start_time,
                EndTime=end_time,
                Period=3600,
                Statistics=['Average', 'Maximum']
            )
            
            # ã‚¨ãƒ©ãƒ¼ç‡
            error_metrics = self.cloudwatch.get_metric_statistics(
                Namespace='AWS/ApiGateway',
                MetricName='4XXError',
                Dimensions=[{'Name': 'ApiName', 'Value': 'ChatApp-API'}],
                StartTime=start_time,
                EndTime=end_time,
                Period=3600,
                Statistics=['Sum']
            )
            
            avg_latency = sum([point['Average'] for point in latency_metrics['Datapoints']]) / len(latency_metrics['Datapoints']) if latency_metrics['Datapoints'] else 0
            max_latency = max([point['Maximum'] for point in latency_metrics['Datapoints']]) if latency_metrics['Datapoints'] else 0
            total_errors = sum([point['Sum'] for point in error_metrics['Datapoints']])
            
            return {
                'avg_response_time_ms': round(avg_latency, 2),
                'max_response_time_ms': round(max_latency, 2),
                'error_count': total_errors,
                'performance_sla_met': avg_latency < 1000,  # 1ç§’æœªæº€ã‚’ç›®æ¨™
                'reliability_score': self.calculate_reliability_score(total_errors, avg_latency)
            }
            
        except Exception as e:
            return {'error': str(e)}
    
    def get_compliance_status(self) -> Dict[str, Any]:
        """ã‚³ãƒ³ãƒ—ãƒ©ã‚¤ã‚¢ãƒ³ã‚¹çŠ¶æ³å–å¾—"""
        try:
            # Config Rules æº–æ‹ çŠ¶æ³
            compliance = self.config.describe_compliance_by_config_rule()
            
            compliant_rules = 0
            non_compliant_rules = 0
            
            for rule in compliance['ComplianceByConfigRules']:
                compliance_type = rule['Compliance']['ComplianceType']
                if compliance_type == 'COMPLIANT':
                    compliant_rules += 1
                elif compliance_type == 'NON_COMPLIANT':
                    non_compliant_rules += 1
            
            total_rules = compliant_rules + non_compliant_rules
            compliance_percentage = (compliant_rules / total_rules * 100) if total_rules > 0 else 0
            
            return {
                'total_rules': total_rules,
                'compliant_rules': compliant_rules,
                'non_compliant_rules': non_compliant_rules,
                'compliance_percentage': round(compliance_percentage, 2),
                'blea_standards_met': compliance_percentage >= 95
            }
            
        except Exception as e:
            return {'error': str(e)}
    
    def get_cost_analysis(self, start_time: datetime, end_time: datetime) -> Dict[str, Any]:
        """ã‚³ã‚¹ãƒˆåˆ†æå–å¾—"""
        try:
            # æœŸé–“ã®ã‚³ã‚¹ãƒˆå–å¾—
            response = self.cost_explorer.get_cost_and_usage(
                TimePeriod={
                    'Start': start_time.strftime('%Y-%m-%d'),
                    'End': end_time.strftime('%Y-%m-%d')
                },
                Granularity='DAILY',
                Metrics=['BlendedCost'],
                GroupBy=[
                    {'Type': 'DIMENSION', 'Key': 'SERVICE'}
                ]
            )
            
            total_cost = 0
            service_costs = {}
            
            for result in response['ResultsByTime']:
                for group in result['Groups']:
                    service = group['Keys'][0]
                    cost = float(group['Metrics']['BlendedCost']['Amount'])
                    total_cost += cost
                    service_costs[service] = service_costs.get(service, 0) + cost
            
            # å‰é€±ã¨ã®æ¯”è¼ƒ
            prev_start = start_time - timedelta(days=7)
            prev_end = start_time
            
            prev_response = self.cost_explorer.get_cost_and_usage(
                TimePeriod={
                    'Start': prev_start.strftime('%Y-%m-%d'),
                    'End': prev_end.strftime('%Y-%m-%d')
                },
                Granularity='DAILY',
                Metrics=['BlendedCost']
            )
            
            prev_total = sum([float(result['Total']['BlendedCost']['Amount']) for result in prev_response['ResultsByTime']])
            cost_change_percentage = ((total_cost - prev_total) / prev_total * 100) if prev_total > 0 else 0
            
            return {
                'total_cost_usd': round(total_cost, 2),
                'cost_by_service': {k: round(v, 2) for k, v in sorted(service_costs.items(), key=lambda x: x[1], reverse=True)[:5]},
                'cost_change_percentage': round(cost_change_percentage, 2),
                'budget_status': 'within_budget' if total_cost < 1000 else 'over_budget'  # ä¾‹: $1000äºˆç®—
            }
            
        except Exception as e:
            return {'error': str(e)}
    
    def generate_recommendations(self, report: Dict[str, Any]) -> List[str]:
        """æ¨å¥¨äº‹é …ç”Ÿæˆ"""
        recommendations = []
        
        # ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æ¨å¥¨äº‹é …
        perf = report.get('performance_metrics', {})
        if perf.get('avg_response_time_ms', 0) > 1000:
            recommendations.append("API response time is above 1 second. Consider optimizing Lambda functions or database queries.")
        
        # ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£æ¨å¥¨äº‹é …
        security = report.get('security_summary', {})
        critical_findings = security.get('findings_by_severity', {}).get('CRITICAL', 0)
        if critical_findings > 0:
            recommendations.append(f"There are {critical_findings} critical security findings that require immediate attention.")
        
        # ã‚³ãƒ³ãƒ—ãƒ©ã‚¤ã‚¢ãƒ³ã‚¹æ¨å¥¨äº‹é …
        compliance = report.get('compliance_status', {})
        if compliance.get('compliance_percentage', 100) < 95:
            recommendations.append("BLEA compliance is below 95%. Review non-compliant Config Rules.")
        
        # ã‚³ã‚¹ãƒˆæ¨å¥¨äº‹é …
        cost = report.get('cost_analysis', {})
        if cost.get('cost_change_percentage', 0) > 20:
            recommendations.append("Cost has increased by more than 20%. Review resource utilization and optimize.")
        
        return recommendations
    
    def save_report(self, report: Dict[str, Any], output_file: str):
        """ãƒ¬ãƒãƒ¼ãƒˆä¿å­˜"""
        with open(output_file, 'w') as f:
            json.dump(report, f, indent=2, default=str)
        
        print(f"Operations report saved to: {output_file}")
    
    def calculate_uptime(self, start_time: datetime, end_time: datetime) -> float:
        """ç¨¼åƒç‡è¨ˆç®—ï¼ˆç°¡æ˜“ç‰ˆï¼‰"""
        # å®Ÿéš›ã®å®Ÿè£…ã§ã¯ã€ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯ã®ãƒ¡ãƒˆãƒªã‚¯ã‚¹ã‚’ä½¿ç”¨
        return 99.9  # ãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ›ãƒ«ãƒ€ãƒ¼
    
    def calculate_reliability_score(self, error_count: int, avg_latency: float) -> float:
        """ä¿¡é ¼æ€§ã‚¹ã‚³ã‚¢è¨ˆç®—"""
        base_score = 100
        error_penalty = min(error_count * 0.1, 20)  # ã‚¨ãƒ©ãƒ¼1ä»¶ã«ã¤ã0.1ç‚¹æ¸›ç‚¹ã€æœ€å¤§20ç‚¹
        latency_penalty = max(0, (avg_latency - 500) * 0.01)  # 500msè¶…éåˆ†ã‚’æ¸›ç‚¹
        
        return max(0, base_score - error_penalty - latency_penalty)
    
    def get_resolved_findings_count(self, start_time: datetime, end_time: datetime) -> int:
        """è§£æ±ºæ¸ˆã¿æ‰€è¦‹æ•°å–å¾—"""
        try:
            resolved_findings = self.security_hub.get_findings(
                Filters={
                    'UpdatedAt': [{'Start': start_time, 'End': end_time}],
                    'RecordState': [{'Value': 'ARCHIVED', 'Comparison': 'EQUALS'}]
                },
                MaxResults=100
            )
            return len(resolved_findings['Findings'])
        except:
            return 0

def main():
    parser = argparse.ArgumentParser(description='Generate Operations Report')
    parser.add_argument('--region', default='ap-northeast-1', help='AWS Region')
    parser.add_argument('--output', default=f'operations-report-{datetime.now().strftime("%Y%m%d")}.json', help='Output file')
    parser.add_argument('--format', choices=['json', 'html'], default='json', help='Output format')
    
    args = parser.parse_args()
    
    generator = OperationsReportGenerator(region=args.region)
    report = generator.generate_weekly_report()
    generator.save_report(report, args.output)
    
    # ã‚µãƒãƒªãƒ¼å‡ºåŠ›
    print("\n=== Operations Report Summary ===")
    print(f"Report Period: {report['report_period']['start']} to {report['report_period']['end']}")
    print(f"System Health: {'âœ… Good' if report['system_health'].get('availability_sla_met') else 'âš ï¸ Issues'}")
    print(f"Security: {report['security_summary'].get('total_findings', 0)} total findings")
    print(f"Performance: {'âœ… Good' if report['performance_metrics'].get('performance_sla_met') else 'âš ï¸ Issues'}")
    print(f"Compliance: {report['compliance_status'].get('compliance_percentage', 0):.1f}%")
    print(f"Cost: ${report['cost_analysis'].get('total_cost_usd', 0):.2f}")
    
    if report['recommendations']:
        print("\n=== Recommendations ===")
        for i, rec in enumerate(report['recommendations'], 1):
            print(f"{i}. {rec}")

if __name__ == "__main__":
    main()
```

## æ¤œè¨¼é …ç›®

- [ ] çµ±åˆé‹ç”¨ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰ãŒè¡¨ç¤ºã•ã‚Œã‚‹
- [ ] ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ç›£è¦–ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰ãŒæ©Ÿèƒ½ã™ã‚‹
- [ ] è‡ªå‹•å¯¾å¿œã‚·ã‚¹ãƒ†ãƒ ãŒå‹•ä½œã™ã‚‹
- [ ] ã‚¢ãƒ©ãƒ¼ãƒˆé€šçŸ¥ã‚·ã‚¹ãƒ†ãƒ ãŒæ©Ÿèƒ½ã™ã‚‹
- [ ] Slackçµ±åˆãŒå‹•ä½œã™ã‚‹
- [ ] ã‚¤ãƒ³ã‚·ãƒ‡ãƒ³ãƒˆè‡ªå‹•ã‚¨ã‚¹ã‚«ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ãŒæ©Ÿèƒ½ã™ã‚‹
- [ ] é‹ç”¨ãƒ¬ãƒãƒ¼ãƒˆãŒè‡ªå‹•ç”Ÿæˆã•ã‚Œã‚‹
- [ ] ã‚³ãƒ³ãƒ—ãƒ©ã‚¤ã‚¢ãƒ³ã‚¹ç›£è¦–ãŒç¶™ç¶šçš„ã«å‹•ä½œã™ã‚‹
- [ ] ã‚³ã‚¹ãƒˆç›£è¦–ã‚¢ãƒ©ãƒ¼ãƒˆãŒæ©Ÿèƒ½ã™ã‚‹
- [ ] è‡ªå‹•ä¿®å¾©æ©Ÿèƒ½ãŒé©åˆ‡ã«å‹•ä½œã™ã‚‹

## é‹ç”¨KPIç›®æ¨™

- [ ] ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚¤ãƒ³ã‚·ãƒ‡ãƒ³ãƒˆæ¤œçŸ¥æ™‚é–“: < 5åˆ†
- [ ] ã‚¤ãƒ³ã‚·ãƒ‡ãƒ³ãƒˆå¯¾å¿œæ™‚é–“: < 15åˆ†
- [ ] è‡ªå‹•å¯¾å¿œæˆåŠŸç‡: > 90%
- [ ] ã‚·ã‚¹ãƒ†ãƒ å¯ç”¨æ€§: > 99.9%
- [ ] ã‚³ãƒ³ãƒ—ãƒ©ã‚¤ã‚¢ãƒ³ã‚¹æº–æ‹ ç‡: > 95%
- [ ] æœˆæ¬¡é‹ç”¨å·¥æ•°: < 8æ™‚é–“

## æ¬¡ã®ã‚¿ã‚¹ã‚¯ã¸ã®å¼•ãç¶™ãäº‹é …

- é‹ç”¨ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰è¨­å®šå®Œäº†
- è‡ªå‹•å¯¾å¿œã‚·ã‚¹ãƒ†ãƒ å‹•ä½œçŠ¶æ³
- ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£é‹ç”¨ãƒ—ãƒ­ã‚»ã‚¹ç¢ºç«‹çŠ¶æ³
- é‹ç”¨ãƒ¬ãƒãƒ¼ãƒˆè‡ªå‹•ç”Ÿæˆæ©Ÿèƒ½

## å‚è€ƒè³‡æ–™

- [AWS Security Hub](https://docs.aws.amazon.com/securityhub/)
- [CloudWatch Dashboards](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch_Dashboards.html)
- [AWS Chatbot](https://docs.aws.amazon.com/chatbot/)
- [Security Incident Response](https://docs.aws.amazon.com/whitepapers/latest/aws-security-incident-response-guide/)
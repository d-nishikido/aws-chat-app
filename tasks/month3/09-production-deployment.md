# Task: æœ¬ç•ªç’°å¢ƒæ§‹ç¯‰ã¨ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆ

**å®Ÿæ–½æœŸé–“**: Month 3 Week 2 (Day 1-2)  
**æ¨å®šå·¥æ•°**: 8æ™‚é–“  
**å„ªå…ˆåº¦**: é«˜  

## æ¦‚è¦

BLEAçµ±åˆæœ¬ç•ªç’°å¢ƒã®æ§‹ç¯‰ã‚’å®Œäº†ã—ã€æœ¬ç•ªãƒ¬ãƒ™ãƒ«ã®ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£è¨­å®šã€ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆã€è² è·ãƒ†ã‚¹ãƒˆã‚’å®Ÿæ–½ã—ã¦æœ¬ç•ªé‹ç”¨æº–å‚™ã‚’æ•´ãˆã‚‹ã€‚

## å­¦ç¿’ç›®æ¨™

- æœ¬ç•ªç’°å¢ƒã§ã®BLEAçµ±åˆæœ€é©åŒ–
- ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆã¨ãƒœãƒˆãƒ«ãƒãƒƒã‚¯è§£æ
- è² è·ãƒ†ã‚¹ãƒˆã«ã‚ˆã‚‹ã‚¹ã‚±ãƒ¼ãƒ©ãƒ“ãƒªãƒ†ã‚£æ¤œè¨¼
- æœ¬ç•ªç›£è¦–ã‚·ã‚¹ãƒ†ãƒ ã®æœ€çµ‚ç¢ºèª

## å‰ææ¡ä»¶

- CI/CD ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³æ§‹ç¯‰å®Œäº†
- é–‹ç™ºãƒ»ã‚¹ãƒ†ãƒ¼ã‚¸ãƒ³ã‚°ç’°å¢ƒã§ã®å‹•ä½œç¢ºèªå®Œäº†
- å…¨ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ†ã‚¹ãƒˆé€šé

## ã‚¿ã‚¹ã‚¯è©³ç´°

### Day 1: æœ¬ç•ªç’°å¢ƒBLEAè¨­å®šæœ€é©åŒ–

#### 1. æœ¬ç•ªç”¨BLEAè¨­å®šå¼·åŒ– (4æ™‚é–“)
- [ ] æœ¬ç•ªç”¨ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒãƒªã‚·ãƒ¼é©ç”¨
- [ ] æœ¬ç•ªãƒ¬ãƒ™ãƒ«ç›£è¦–è¨­å®š
- [ ] ç½å®³å¾©æ—§è¨­å®šå¼·åŒ–
- [ ] ã‚³ãƒ³ãƒ—ãƒ©ã‚¤ã‚¢ãƒ³ã‚¹è¨­å®šæœ€çµ‚ç¢ºèª

#### 2. æœ¬ç•ªã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£å¼·åŒ– (3æ™‚é–“)
- [ ] WAF ãƒ«ãƒ¼ãƒ«æœ€é©åŒ–
- [ ] æš—å·åŒ–è¨­å®šå¼·åŒ–
- [ ] ã‚¢ã‚¯ã‚»ã‚¹åˆ¶å¾¡æœ€çµ‚ç¢ºèª
- [ ] ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ­ã‚°è¨­å®šç¢ºèª

#### 3. æœ¬ç•ªç›£è¦–è¨­å®š (1æ™‚é–“)
- [ ] CloudWatch è©³ç´°ç›£è¦–æœ‰åŠ¹åŒ–
- [ ] ã‚«ã‚¹ã‚¿ãƒ ãƒ¡ãƒˆãƒªã‚¯ã‚¹è¨­å®š
- [ ] ã‚¢ãƒ©ãƒ¼ãƒˆé–¾å€¤èª¿æ•´
- [ ] é€šçŸ¥è¨­å®šæœ€çµ‚ç¢ºèª

### Day 2: ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆã¨æœ€é©åŒ–

#### 1. BLEAçµ±åˆè² è·ãƒ†ã‚¹ãƒˆ (4æ™‚é–“)
- [ ] ãƒ™ãƒ¼ã‚¹ãƒ©ã‚¤ãƒ³æ€§èƒ½æ¸¬å®š
- [ ] æ®µéšçš„è² è·ãƒ†ã‚¹ãƒˆ
- [ ] ãƒ”ãƒ¼ã‚¯è² è·ãƒ†ã‚¹ãƒˆ
- [ ] ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£æ©Ÿèƒ½ã¸ã®å½±éŸ¿æ¸¬å®š

#### 2. ãƒœãƒˆãƒ«ãƒãƒƒã‚¯è§£æã¨æœ€é©åŒ– (2æ™‚é–“)
- [ ] ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹åˆ†æ
- [ ] ãƒªã‚½ãƒ¼ã‚¹ä½¿ç”¨ç‡ç¢ºèª
- [ ] æœ€é©åŒ–å®Ÿè£…
- [ ] æ”¹å–„åŠ¹æœæ¸¬å®š

#### 3. æœ¬ç•ªãƒ‡ãƒ—ãƒ­ã‚¤æœ€çµ‚ç¢ºèª (2æ™‚é–“)
- [ ] ãƒ‡ãƒ—ãƒ­ã‚¤ãƒªãƒãƒ¼ã‚µãƒ«
- [ ] ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯æ‰‹é †ç¢ºèª
- [ ] æœ¬ç•ªãƒ‡ãƒ—ãƒ­ã‚¤å®Ÿè¡Œ
- [ ] ãƒ‡ãƒ—ãƒ­ã‚¤å¾Œæ¤œè¨¼

### MCP ã‚µãƒ¼ãƒæ´»ç”¨

```
ğŸ’¬ "æœ¬ç•ªç’°å¢ƒã§ã®BLEAçµ±åˆæœ€é©åŒ–ã¨ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆã‚’å®Ÿæ–½ã—ã¦ãã ã•ã„ã€‚
ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£æ©Ÿèƒ½ã‚’ç¶­æŒã—ãªãŒã‚‰æœ€é©ãªãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã‚’å®Ÿç¾ã™ã‚‹è¨­å®šã‚’ææ¡ˆã—ã¦ãã ã•ã„ã€‚"
```

## æˆæœç‰©

### 1. æœ¬ç•ªç’°å¢ƒBLEAè¨­å®š

```typescript
// lib/environments/production-config.ts
export const productionConfig = {
  // BLEAæœ¬ç•ªè¨­å®š
  blea: {
    governance: {
      // æœ¬ç•ªãƒ¬ãƒ™ãƒ«ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£çµ±åˆ¶
      securityNotifyEmail: 'security-team@company.com',
      emergencyContactEmail: 'emergency@company.com',
      enableAdvancedThreatProtection: true,
      enableRealTimeMonitoring: true,
      
      // GuardDutyæœ¬ç•ªè¨­å®š
      guardDuty: {
        findingPublishingFrequency: 'FIFTEEN_MINUTES',
        enableS3Protection: true,
        enableKubernetesProtection: true,
        enableMalwareProtection: true
      },
      
      // Security Hubæœ¬ç•ªè¨­å®š
      securityHub: {
        enableCISStandard: true,
        enableAWSFoundationalStandard: true,
        enablePCIDSSStandard: true,
        autoRemediationEnabled: true
      },
      
      // Configæœ¬ç•ªè¨­å®š
      config: {
        includeGlobalResourceTypes: true,
        enableConfigurationHistory: true,
        enableCompliancePackDeployment: true,
        customRulesEnabled: true
      }
    },
    
    // æœ¬ç•ªç›£è¦–è¨­å®š
    monitoring: {
      cloudWatch: {
        detailedMonitoring: true,
        customMetrics: true,
        logRetentionDays: 365,
        enableInsights: true
      },
      
      alerts: {
        // é‡è¦åº¦åˆ¥ã‚¢ãƒ©ãƒ¼ãƒˆè¨­å®š
        critical: {
          responseTime: '< 5 minutes',
          channels: ['email', 'slack', 'pagerduty']
        },
        high: {
          responseTime: '< 15 minutes',
          channels: ['email', 'slack']
        },
        medium: {
          responseTime: '< 1 hour',
          channels: ['slack']
        }
      }
    }
  },
  
  // ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³æœ¬ç•ªè¨­å®š
  application: {
    scaling: {
      lambda: {
        reservedConcurrency: 100,
        provisionedConcurrency: 20,
        timeout: 30,
        memorySize: 1024
      },
      
      aurora: {
        serverlessV2: {
          minCapacity: 2,
          maxCapacity: 16,
          autoPause: false
        },
        performanceInsights: {
          enabled: true,
          retentionPeriod: 7
        }
      },
      
      apiGateway: {
        throttling: {
          rateLimit: 10000,
          burstLimit: 5000
        },
        caching: {
          enabled: true,
          ttl: 300,
          encrypted: true
        }
      }
    },
    
    security: {
      waf: {
        rules: [
          'AWSManagedRulesCommonRuleSet',
          'AWSManagedRulesKnownBadInputsRuleSet',
          'AWSManagedRulesSQLiRuleSet',
          'AWSManagedRulesLinuxRuleSet',
          'AWSManagedRulesAmazonIpReputationList'
        ],
        rateBasedRules: {
          enabled: true,
          limit: 2000,
          action: 'BLOCK'
        }
      },
      
      encryption: {
        kmsKeyRotation: true,
        s3DefaultEncryption: true,
        efsEncryption: true,
        rdsEncryption: true
      }
    }
  }
};

// æœ¬ç•ªç’°å¢ƒCDKã‚¹ã‚¿ãƒƒã‚¯
export class ProductionChatAppStack extends cdk.Stack {
  constructor(scope: Construct, id: string, props?: cdk.StackProps) {
    super(scope, id, props);

    // æœ¬ç•ªç”¨ã‚¿ã‚°è¨­å®š
    cdk.Tags.of(this).add('Environment', 'production');
    cdk.Tags.of(this).add('CostCenter', 'engineering');
    cdk.Tags.of(this).add('Owner', 'chatapp-team');
    cdk.Tags.of(this).add('Compliance', 'required');
    cdk.Tags.of(this).add('BackupSchedule', 'daily');

    // BLEAæœ¬ç•ªã‚¬ãƒãƒŠãƒ³ã‚¹
    const governance = new BLEAGovernanceStack(this, 'ProductionGovernance', {
      ...productionConfig.blea.governance,
      environment: 'production'
    });

    // æœ¬ç•ªVPCï¼ˆå¯ç”¨æ€§é‡è¦–ï¼‰
    const vpc = new ec2.Vpc(this, 'ProductionVPC', {
      cidr: '10.1.0.0/16',
      maxAzs: 3,  // æœ¬ç•ªã¯3AZæ§‹æˆ
      enableDnsHostnames: true,
      enableDnsSupport: true,
      
      subnetConfiguration: [
        {
          name: 'Public',
          subnetType: ec2.SubnetType.PUBLIC,
          cidrMask: 24,
        },
        {
          name: 'Private',
          subnetType: ec2.SubnetType.PRIVATE_WITH_EGRESS,
          cidrMask: 24,
        },
        {
          name: 'Database',
          subnetType: ec2.SubnetType.PRIVATE_ISOLATED,
          cidrMask: 24,
        }
      ],
      
      // æœ¬ç•ªç”¨NAT Gatewayï¼ˆå„AZã«é…ç½®ï¼‰
      natGateways: 3,
      
      // ãƒ•ãƒ­ãƒ¼ãƒ­ã‚°æœ‰åŠ¹åŒ–
      flowLogs: {
        's3': {
          destination: ec2.FlowLogDestination.toS3(),
          trafficType: ec2.FlowLogTrafficType.ALL
        }
      }
    });

    // æœ¬ç•ªAuroraï¼ˆé«˜å¯ç”¨æ€§è¨­å®šï¼‰
    const productionAurora = new rds.DatabaseCluster(this, 'ProductionAurora', {
      engine: rds.DatabaseClusterEngine.auroraPostgres({
        version: rds.AuroraPostgresEngineVersion.VER_14_9
      }),
      
      // æœ¬ç•ªãƒ¬ãƒ—ãƒªã‚«è¨­å®š
      writer: rds.ClusterInstance.serverlessV2('writer', {
        scaleWithWriter: true
      }),
      readers: [
        rds.ClusterInstance.serverlessV2('reader1', {
          scaleWithWriter: true
        }),
        rds.ClusterInstance.serverlessV2('reader2', {
          scaleWithWriter: true
        })
      ],
      
      vpc,
      vpcSubnets: {
        subnetType: ec2.SubnetType.PRIVATE_ISOLATED
      },
      
      // æœ¬ç•ªãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—è¨­å®š
      backup: {
        retention: cdk.Duration.days(30),
        preferredWindow: '03:00-04:00'
      },
      
      // æœ¬ç•ªã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£è¨­å®š
      storageEncrypted: true,
      monitoringInterval: cdk.Duration.seconds(60),
      performanceInsightRetention: rds.PerformanceInsightRetention.LONG_TERM,
      
      cloudwatchLogsExports: ['postgresql'],
      cloudwatchLogsRetention: logs.RetentionDays.ONE_YEAR,
      
      deletionProtection: true
    });

    // æœ¬ç•ªCloudFrontï¼ˆãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–ï¼‰
    const distribution = new cloudfront.Distribution(this, 'ProductionDistribution', {
      defaultBehavior: {
        origin: new origins.S3Origin(this.websiteBucket),
        viewerProtocolPolicy: cloudfront.ViewerProtocolPolicy.REDIRECT_TO_HTTPS,
        
        // ã‚­ãƒ£ãƒƒã‚·ãƒ¥æœ€é©åŒ–
        cachePolicy: cloudfront.CachePolicy.CACHING_OPTIMIZED,
        originRequestPolicy: cloudfront.OriginRequestPolicy.CORS_S3_ORIGIN,
        
        // åœ§ç¸®æœ‰åŠ¹åŒ–
        compress: true,
        
        // ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ˜ãƒƒãƒ€ãƒ¼
        responseHeadersPolicy: this.createSecurityHeadersPolicy()
      },
      
      // è¤‡æ•°ã‚ªãƒªã‚¸ãƒ³è¨­å®š
      additionalBehaviors: {
        '/api/*': {
          origin: new origins.HttpOrigin(this.apiDomain),
          cachePolicy: cloudfront.CachePolicy.CACHING_DISABLED,
          allowedMethods: cloudfront.AllowedMethods.ALLOW_ALL,
          viewerProtocolPolicy: cloudfront.ViewerProtocolPolicy.REDIRECT_TO_HTTPS
        }
      },
      
      // æœ¬ç•ªç”¨è¨­å®š
      enabled: true,
      httpVersion: cloudfront.HttpVersion.HTTP2,
      priceClass: cloudfront.PriceClass.PRICE_CLASS_ALL,
      
      // ãƒ­ã‚°è¨­å®š
      enableLogging: true,
      logBucket: this.logsBucket,
      logFilePrefix: 'cloudfront-logs/',
      
      // SSLè¨¼æ˜æ›¸
      certificate: this.sslCertificate,
      domainNames: ['chat.company.com']
    });

    // æœ¬ç•ªç›£è¦–ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰
    this.createProductionDashboard(productionAurora, distribution);
  }

  private createSecurityHeadersPolicy(): cloudfront.ResponseHeadersPolicy {
    return new cloudfront.ResponseHeadersPolicy(this, 'SecurityHeaders', {
      securityHeadersBehavior: {
        contentSecurityPolicy: {
          contentSecurityPolicy: "default-src 'self'; img-src 'self' data: https:; script-src 'self' 'unsafe-inline'",
          override: true
        },
        frameOptions: {
          frameOption: cloudfront.HeadersFrameOption.DENY,
          override: true
        },
        contentTypeOptions: {
          override: true
        },
        strictTransportSecurity: {
          accessControlMaxAge: cdk.Duration.seconds(31536000),
          includeSubDomains: true,
          preload: true,
          override: true
        },
        referrerPolicy: {
          referrerPolicy: cloudfront.HeadersReferrerPolicy.STRICT_ORIGIN_WHEN_CROSS_ORIGIN,
          override: true
        }
      }
    });
  }

  private createProductionDashboard(
    aurora: rds.DatabaseCluster,
    distribution: cloudfront.Distribution
  ) {
    const dashboard = new cloudwatch.Dashboard(this, 'ProductionDashboard', {
      dashboardName: 'ChatApp-Production-Dashboard',
      widgets: [
        // ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ãƒ¡ãƒˆãƒªã‚¯ã‚¹
        [
          new cloudwatch.GraphWidget({
            title: 'API Response Times',
            left: [
              new cloudwatch.Metric({
                namespace: 'AWS/ApiGateway',
                metricName: 'Latency',
                dimensionsMap: {
                  ApiName: 'ChatApp-Production-API'
                },
                statistic: 'Average'
              })
            ]
          })
        ],
        
        // ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ãƒ¡ãƒˆãƒªã‚¯ã‚¹
        [
          new cloudwatch.GraphWidget({
            title: 'Aurora Performance',
            left: [
              aurora.metricCPUUtilization(),
              aurora.metricDatabaseConnections()
            ]
          })
        ],
        
        // ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ¡ãƒˆãƒªã‚¯ã‚¹
        [
          new cloudwatch.GraphWidget({
            title: 'Security Events',
            left: [
              new cloudwatch.Metric({
                namespace: 'AWS/WAF',
                metricName: 'BlockedRequests',
                statistic: 'Sum'
              })
            ]
          })
        ]
      ]
    });
    
    return dashboard;
  }
}
```

### 2. ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆã‚¹ã‚¯ãƒªãƒ—ãƒˆ

```python
# scripts/performance-test.py
"""
æœ¬ç•ªç’°å¢ƒãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆ
"""

import asyncio
import aiohttp
import time
import json
import argparse
import boto3
from datetime import datetime
from typing import Dict, List, Any
from dataclasses import dataclass
import statistics

@dataclass
class TestResult:
    endpoint: str
    method: str
    response_time: float
    status_code: int
    success: bool
    timestamp: datetime
    error_message: str = None

class PerformanceTestSuite:
    def __init__(self, base_url: str, cognito_config: Dict[str, str]):
        self.base_url = base_url
        self.cognito_config = cognito_config
        self.auth_token = None
        self.test_results: List[TestResult] = []
        
    async def setup_authentication(self):
        """Cognitoèªè¨¼ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—"""
        import boto3
        from botocore.exceptions import ClientError
        
        try:
            client = boto3.client('cognito-idp', region_name='ap-northeast-1')
            
            # ãƒ†ã‚¹ãƒˆç”¨ãƒ¦ãƒ¼ã‚¶ãƒ¼ã§ãƒ­ã‚°ã‚¤ãƒ³
            response = client.admin_initiate_auth(
                UserPoolId=self.cognito_config['user_pool_id'],
                ClientId=self.cognito_config['client_id'],
                AuthFlow='ADMIN_NO_SRP_AUTH',
                AuthParameters={
                    'USERNAME': self.cognito_config['test_username'],
                    'PASSWORD': self.cognito_config['test_password']
                }
            )
            
            self.auth_token = response['AuthenticationResult']['IdToken']
            print(f"Authentication successful for user: {self.cognito_config['test_username']}")
            
        except ClientError as e:
            print(f"Authentication failed: {e}")
            raise
    
    async def run_endpoint_test(
        self, 
        session: aiohttp.ClientSession, 
        endpoint: str, 
        method: str = 'GET',
        payload: Dict = None,
        headers: Dict = None
    ) -> TestResult:
        """å˜ä¸€ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆãƒ†ã‚¹ãƒˆ"""
        start_time = time.time()
        
        # èªè¨¼ãƒ˜ãƒƒãƒ€ãƒ¼è¿½åŠ 
        if headers is None:
            headers = {}
        if self.auth_token:
            headers['Authorization'] = f'Bearer {self.auth_token}'
        
        url = f"{self.base_url}{endpoint}"
        
        try:
            async with session.request(method, url, json=payload, headers=headers) as response:
                await response.text()  # ãƒ¬ã‚¹ãƒãƒ³ã‚¹èª­ã¿å–ã‚Š
                response_time = time.time() - start_time
                
                result = TestResult(
                    endpoint=endpoint,
                    method=method,
                    response_time=response_time,
                    status_code=response.status,
                    success=200 <= response.status < 300,
                    timestamp=datetime.utcnow()
                )
                
        except Exception as e:
            response_time = time.time() - start_time
            result = TestResult(
                endpoint=endpoint,
                method=method,
                response_time=response_time,
                status_code=0,
                success=False,
                timestamp=datetime.utcnow(),
                error_message=str(e)
            )
        
        self.test_results.append(result)
        return result
    
    async def run_load_test(
        self, 
        endpoint: str, 
        concurrent_users: int, 
        duration_seconds: int
    ) -> List[TestResult]:
        """è² è·ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ"""
        print(f"Starting load test: {concurrent_users} concurrent users for {duration_seconds}s")
        
        async with aiohttp.ClientSession() as session:
            tasks = []
            end_time = time.time() + duration_seconds
            
            # ä¸¦è¡Œãƒªã‚¯ã‚¨ã‚¹ãƒˆå®Ÿè¡Œ
            for _ in range(concurrent_users):
                task = asyncio.create_task(
                    self.continuous_requests(session, endpoint, end_time)
                )
                tasks.append(task)
            
            # å…¨ã‚¿ã‚¹ã‚¯å®Œäº†å¾…æ©Ÿ
            results = await asyncio.gather(*tasks, return_exceptions=True)
            
        # ã‚¨ãƒ©ãƒ¼çµæœã‚’é™¤å¤–
        successful_results = [r for r in results if isinstance(r, list)]
        flattened_results = [item for sublist in successful_results for item in sublist]
        
        return flattened_results
    
    async def continuous_requests(
        self, 
        session: aiohttp.ClientSession, 
        endpoint: str, 
        end_time: float
    ) -> List[TestResult]:
        """ç¶™ç¶šçš„ãƒªã‚¯ã‚¨ã‚¹ãƒˆé€ä¿¡"""
        results = []
        
        while time.time() < end_time:
            result = await self.run_endpoint_test(session, endpoint)
            results.append(result)
            
            # çŸ­ã„é–“éš”ã§æ¬¡ã®ãƒªã‚¯ã‚¨ã‚¹ãƒˆ
            await asyncio.sleep(0.1)
        
        return results
    
    def analyze_results(self, results: List[TestResult]) -> Dict[str, Any]:
        """çµæœåˆ†æ"""
        if not results:
            return {'error': 'No test results available'}
        
        successful_results = [r for r in results if r.success]
        response_times = [r.response_time for r in successful_results]
        
        if not response_times:
            return {'error': 'No successful requests'}
        
        analysis = {
            'total_requests': len(results),
            'successful_requests': len(successful_results),
            'failed_requests': len(results) - len(successful_results),
            'success_rate': len(successful_results) / len(results) * 100,
            
            'response_times': {
                'min': min(response_times),
                'max': max(response_times),
                'mean': statistics.mean(response_times),
                'median': statistics.median(response_times),
                'p95': self.percentile(response_times, 95),
                'p99': self.percentile(response_times, 99)
            },
            
            'throughput': {
                'requests_per_second': len(successful_results) / (max(response_times) if response_times else 1)
            },
            
            'status_codes': self.count_status_codes(results),
            'errors': [r.error_message for r in results if not r.success and r.error_message]
        }
        
        return analysis
    
    def percentile(self, data: List[float], percentile: float) -> float:
        """ãƒ‘ãƒ¼ã‚»ãƒ³ã‚¿ã‚¤ãƒ«è¨ˆç®—"""
        sorted_data = sorted(data)
        index = int(len(sorted_data) * percentile / 100)
        return sorted_data[min(index, len(sorted_data) - 1)]
    
    def count_status_codes(self, results: List[TestResult]) -> Dict[int, int]:
        """ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚³ãƒ¼ãƒ‰é›†è¨ˆ"""
        status_counts = {}
        for result in results:
            status_counts[result.status_code] = status_counts.get(result.status_code, 0) + 1
        return status_counts
    
    async def run_comprehensive_test(self):
        """åŒ…æ‹¬çš„ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆ"""
        print("Starting comprehensive performance test...")
        
        # èªè¨¼ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—
        await self.setup_authentication()
        
        # ãƒ†ã‚¹ãƒˆã‚·ãƒŠãƒªã‚ª
        test_scenarios = [
            {'name': 'Light Load', 'users': 10, 'duration': 60},
            {'name': 'Medium Load', 'users': 50, 'duration': 120},
            {'name': 'Heavy Load', 'users': 100, 'duration': 180},
            {'name': 'Peak Load', 'users': 200, 'duration': 300}
        ]
        
        test_endpoints = [
            '/api/v1/rooms',
            '/api/v1/users/me',
            '/api/v1/rooms/test-room/messages'
        ]
        
        comprehensive_results = {}
        
        for scenario in test_scenarios:
            print(f"\n--- Running {scenario['name']} ---")
            scenario_results = {}
            
            for endpoint in test_endpoints:
                print(f"Testing endpoint: {endpoint}")
                
                results = await self.run_load_test(
                    endpoint=endpoint,
                    concurrent_users=scenario['users'],
                    duration_seconds=scenario['duration']
                )
                
                analysis = self.analyze_results(results)
                scenario_results[endpoint] = analysis
                
                print(f"Success rate: {analysis.get('success_rate', 0):.2f}%")
                print(f"Mean response time: {analysis.get('response_times', {}).get('mean', 0):.3f}s")
                print(f"P95 response time: {analysis.get('response_times', {}).get('p95', 0):.3f}s")
            
            comprehensive_results[scenario['name']] = scenario_results
        
        return comprehensive_results
    
    def generate_report(self, results: Dict[str, Any], output_file: str):
        """ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆ"""
        report = {
            'test_timestamp': datetime.utcnow().isoformat(),
            'test_environment': 'production',
            'base_url': self.base_url,
            'results': results,
            'recommendations': self.generate_recommendations(results)
        }
        
        with open(output_file, 'w') as f:
            json.dump(report, f, indent=2)
        
        print(f"Performance report saved to: {output_file}")
    
    def generate_recommendations(self, results: Dict[str, Any]) -> List[str]:
        """æœ€é©åŒ–æ¨å¥¨äº‹é …ç”Ÿæˆ"""
        recommendations = []
        
        for scenario_name, scenario_results in results.items():
            for endpoint, analysis in scenario_results.items():
                success_rate = analysis.get('success_rate', 0)
                mean_response_time = analysis.get('response_times', {}).get('mean', 0)
                p95_response_time = analysis.get('response_times', {}).get('p95', 0)
                
                if success_rate < 95:
                    recommendations.append(
                        f"{endpoint}: Low success rate ({success_rate:.1f}%) in {scenario_name} - investigate error handling"
                    )
                
                if mean_response_time > 1.0:
                    recommendations.append(
                        f"{endpoint}: High mean response time ({mean_response_time:.2f}s) in {scenario_name} - consider optimization"
                    )
                
                if p95_response_time > 2.0:
                    recommendations.append(
                        f"{endpoint}: High P95 response time ({p95_response_time:.2f}s) in {scenario_name} - investigate outliers"
                    )
        
        return recommendations

async def main():
    parser = argparse.ArgumentParser(description='Production Performance Test')
    parser.add_argument('--base-url', required=True, help='API base URL')
    parser.add_argument('--user-pool-id', required=True, help='Cognito User Pool ID')
    parser.add_argument('--client-id', required=True, help='Cognito Client ID')
    parser.add_argument('--test-username', required=True, help='Test user username')
    parser.add_argument('--test-password', required=True, help='Test user password')
    parser.add_argument('--output', default='performance-report.json', help='Output report file')
    
    args = parser.parse_args()
    
    cognito_config = {
        'user_pool_id': args.user_pool_id,
        'client_id': args.client_id,
        'test_username': args.test_username,
        'test_password': args.test_password
    }
    
    test_suite = PerformanceTestSuite(args.base_url, cognito_config)
    
    try:
        results = await test_suite.run_comprehensive_test()
        test_suite.generate_report(results, args.output)
        print("\nPerformance test completed successfully!")
        
    except Exception as e:
        print(f"Performance test failed: {str(e)}")
        raise

if __name__ == "__main__":
    asyncio.run(main())
```

### 3. æœ¬ç•ªãƒ‡ãƒ—ãƒ­ã‚¤ã‚¹ã‚¯ãƒªãƒ—ãƒˆ

```python
# scripts/production-deployment.py
"""
æœ¬ç•ªãƒ‡ãƒ—ãƒ­ã‚¤ãƒ¡ãƒ³ãƒˆã‚¹ã‚¯ãƒªãƒ—ãƒˆ
"""

import boto3
import json
import time
import subprocess
from datetime import datetime
from typing import Dict, List, Any

class ProductionDeployer:
    def __init__(self, region='ap-northeast-1'):
        self.region = region
        self.cloudformation = boto3.client('cloudformation', region_name=region)
        self.codepipeline = boto3.client('codepipeline', region_name=region)
        self.cloudwatch = boto3.client('cloudwatch', region_name=region)
        
    def pre_deployment_checks(self) -> Dict[str, bool]:
        """ãƒ‡ãƒ—ãƒ­ã‚¤å‰ãƒã‚§ãƒƒã‚¯"""
        checks = {
            'pipeline_healthy': self.check_pipeline_health(),
            'staging_tests_passed': self.check_staging_tests(),
            'security_scan_passed': self.check_security_scans(),
            'blea_compliance': self.check_blea_compliance(),
            'database_backup': self.verify_database_backup()
        }
        
        print("Pre-deployment checks:")
        for check, status in checks.items():
            print(f"  {check}: {'âœ… PASS' if status else 'âŒ FAIL'}")
        
        return checks
    
    def check_pipeline_health(self) -> bool:
        """ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³å¥å…¨æ€§ç¢ºèª"""
        try:
            response = self.codepipeline.get_pipeline_state(
                name='ChatApp-BLEA-Pipeline'
            )
            
            # æœ€æ–°å®Ÿè¡ŒãŒæˆåŠŸã—ã¦ã„ã‚‹ã“ã¨ã‚’ç¢ºèª
            stage_states = response['stageStates']
            for stage in stage_states:
                if stage['stageName'] == 'Dev':
                    return stage['latestExecution']['status'] == 'Succeeded'
                    
            return False
        except Exception as e:
            print(f"Pipeline health check failed: {e}")
            return False
    
    def check_staging_tests(self) -> bool:
        """ã‚¹ãƒ†ãƒ¼ã‚¸ãƒ³ã‚°ç’°å¢ƒãƒ†ã‚¹ãƒˆçµæœç¢ºèª"""
        try:
            # CodeBuildãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®æœ€æ–°å®Ÿè¡Œçµæœã‚’ç¢ºèª
            codebuild = boto3.client('codebuild', region_name=self.region)
            
            response = codebuild.list_builds_for_project(
                projectName='ChatApp-Staging-Tests'
            )
            
            if response['ids']:
                build_details = codebuild.batch_get_builds(ids=[response['ids'][0]])
                latest_build = build_details['builds'][0]
                return latest_build['buildStatus'] == 'SUCCEEDED'
            
            return False
        except Exception as e:
            print(f"Staging tests check failed: {e}")
            return False
    
    def check_security_scans(self) -> bool:
        """ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚¹ã‚­ãƒ£ãƒ³çµæœç¢ºèª"""
        # Security Hub ã‹ã‚‰æœ€æ–°ã®æ‰€è¦‹ã‚’ç¢ºèª
        try:
            securityhub = boto3.client('securityhub', region_name=self.region)
            
            response = securityhub.get_findings(
                Filters={
                    'ProductName': [{'Value': 'ChatApp', 'Comparison': 'EQUALS'}],
                    'RecordState': [{'Value': 'ACTIVE', 'Comparison': 'EQUALS'}],
                    'SeverityLabel': [{'Value': 'HIGH', 'Comparison': 'EQUALS'}, 
                                    {'Value': 'CRITICAL', 'Comparison': 'EQUALS'}]
                },
                MaxResults=1
            )
            
            # é«˜é‡è¦åº¦ã®æ‰€è¦‹ãŒãªã„ã“ã¨ã‚’ç¢ºèª
            return len(response['Findings']) == 0
            
        except Exception as e:
            print(f"Security scan check failed: {e}")
            return False
    
    def check_blea_compliance(self) -> bool:
        """BLEAæº–æ‹ æ€§ç¢ºèª"""
        try:
            config = boto3.client('config', region_name=self.region)
            
            # Config Rules ã®æº–æ‹ çŠ¶æ³ç¢ºèª
            response = config.describe_compliance_by_config_rule()
            
            non_compliant_rules = [
                rule for rule in response['ComplianceByConfigRules']
                if rule['Compliance']['ComplianceType'] == 'NON_COMPLIANT'
            ]
            
            return len(non_compliant_rules) == 0
            
        except Exception as e:
            print(f"BLEA compliance check failed: {e}")
            return False
    
    def verify_database_backup(self) -> bool:
        """ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ç¢ºèª"""
        try:
            rds = boto3.client('rds', region_name=self.region)
            
            # æœ€æ–°ã®ã‚¹ãƒŠãƒƒãƒ—ã‚·ãƒ§ãƒƒãƒˆç¢ºèª
            response = rds.describe_db_cluster_snapshots(
                DBClusterIdentifier='chatapp-production-cluster',
                SnapshotType='automated',
                MaxRecords=1
            )
            
            if response['DBClusterSnapshots']:
                latest_snapshot = response['DBClusterSnapshots'][0]
                snapshot_time = latest_snapshot['SnapshotCreateTime']
                
                # 24æ™‚é–“ä»¥å†…ã®ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãŒã‚ã‚‹ã“ã¨ã‚’ç¢ºèª
                time_diff = datetime.utcnow().replace(tzinfo=None) - snapshot_time.replace(tzinfo=None)
                return time_diff.total_seconds() < 86400  # 24 hours
            
            return False
            
        except Exception as e:
            print(f"Database backup check failed: {e}")
            return False
    
    def deploy_to_production(self) -> bool:
        """æœ¬ç•ªãƒ‡ãƒ—ãƒ­ã‚¤å®Ÿè¡Œ"""
        try:
            print("Starting production deployment...")
            
            # CDK ãƒ‡ãƒ—ãƒ­ã‚¤å®Ÿè¡Œ
            cmd = [
                'npx', 'cdk', 'deploy', 'ChatApp-Production-Stack',
                '--require-approval', 'never',
                '--context', 'environment=production',
                '--context', 'blea-enabled=true'
            ]
            
            result = subprocess.run(cmd, capture_output=True, text=True)
            
            if result.returncode == 0:
                print("Production deployment successful!")
                return True
            else:
                print(f"Production deployment failed: {result.stderr}")
                return False
                
        except Exception as e:
            print(f"Deployment failed: {e}")
            return False
    
    def post_deployment_verification(self) -> Dict[str, bool]:
        """ãƒ‡ãƒ—ãƒ­ã‚¤å¾Œæ¤œè¨¼"""
        checks = {
            'stack_status': self.verify_stack_status(),
            'health_checks': self.verify_health_checks(),
            'monitoring_active': self.verify_monitoring(),
            'api_response': self.verify_api_endpoints()
        }
        
        print("Post-deployment verification:")
        for check, status in checks.items():
            print(f"  {check}: {'âœ… PASS' if status else 'âŒ FAIL'}")
        
        return checks
    
    def verify_stack_status(self) -> bool:
        """CloudFormationã‚¹ã‚¿ãƒƒã‚¯çŠ¶æ…‹ç¢ºèª"""
        try:
            response = self.cloudformation.describe_stacks(
                StackName='ChatApp-Production-Stack'
            )
            
            stack = response['Stacks'][0]
            return stack['StackStatus'] == 'CREATE_COMPLETE' or stack['StackStatus'] == 'UPDATE_COMPLETE'
            
        except Exception as e:
            print(f"Stack status check failed: {e}")
            return False
    
    def verify_health_checks(self) -> bool:
        """ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯ç¢ºèª"""
        try:
            # API Gateway health check
            import requests
            
            response = requests.get('https://api.chatapp.com/health', timeout=10)
            return response.status_code == 200
            
        except Exception as e:
            print(f"Health check failed: {e}")
            return False
    
    def verify_monitoring(self) -> bool:
        """ç›£è¦–ã‚·ã‚¹ãƒ†ãƒ å‹•ä½œç¢ºèª"""
        try:
            # CloudWatch ã‚¢ãƒ©ãƒ¼ãƒ çŠ¶æ…‹ç¢ºèª
            response = self.cloudwatch.describe_alarms(
                StateValue='ALARM'
            )
            
            # ã‚¢ãƒ©ãƒ¼ãƒ çŠ¶æ…‹ã®ã‚¢ãƒ©ãƒ¼ãƒ ãŒãªã„ã“ã¨ã‚’ç¢ºèª
            return len(response['MetricAlarms']) == 0
            
        except Exception as e:
            print(f"Monitoring verification failed: {e}")
            return False
    
    def verify_api_endpoints(self) -> bool:
        """API ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆå‹•ä½œç¢ºèª"""
        try:
            import requests
            
            endpoints = [
                'https://api.chatapp.com/api/v1/health',
                'https://api.chatapp.com/api/v1/rooms'
            ]
            
            for endpoint in endpoints:
                response = requests.get(endpoint, timeout=10)
                if response.status_code not in [200, 401]:  # 401 is expected for protected endpoints
                    return False
            
            return True
            
        except Exception as e:
            print(f"API endpoint verification failed: {e}")
            return False
    
    def create_deployment_report(self, pre_checks: Dict, post_checks: Dict) -> str:
        """ãƒ‡ãƒ—ãƒ­ã‚¤ãƒ¬ãƒãƒ¼ãƒˆä½œæˆ"""
        report = {
            'deployment_timestamp': datetime.utcnow().isoformat(),
            'environment': 'production',
            'pre_deployment_checks': pre_checks,
            'post_deployment_checks': post_checks,
            'overall_success': all(pre_checks.values()) and all(post_checks.values())
        }
        
        report_file = f"deployment-report-{datetime.utcnow().strftime('%Y%m%d-%H%M%S')}.json"
        
        with open(report_file, 'w') as f:
            json.dump(report, f, indent=2)
        
        return report_file

def main():
    deployer = ProductionDeployer()
    
    print("=== Production Deployment Process ===")
    
    # ãƒ‡ãƒ—ãƒ­ã‚¤å‰ãƒã‚§ãƒƒã‚¯
    pre_checks = deployer.pre_deployment_checks()
    
    if not all(pre_checks.values()):
        print("âŒ Pre-deployment checks failed. Aborting deployment.")
        return False
    
    # æœ¬ç•ªãƒ‡ãƒ—ãƒ­ã‚¤å®Ÿè¡Œ
    deployment_success = deployer.deploy_to_production()
    
    if not deployment_success:
        print("âŒ Production deployment failed.")
        return False
    
    # ãƒ‡ãƒ—ãƒ­ã‚¤å¾Œæ¤œè¨¼
    time.sleep(60)  # ã‚µãƒ¼ãƒ“ã‚¹èµ·å‹•å¾…æ©Ÿ
    post_checks = deployer.post_deployment_verification()
    
    # ãƒ¬ãƒãƒ¼ãƒˆä½œæˆ
    report_file = deployer.create_deployment_report(pre_checks, post_checks)
    
    overall_success = all(post_checks.values())
    
    if overall_success:
        print("âœ… Production deployment completed successfully!")
        print(f"ğŸ“Š Deployment report: {report_file}")
    else:
        print("âš ï¸  Production deployment completed with issues.")
        print(f"ğŸ“Š Deployment report: {report_file}")
    
    return overall_success

if __name__ == "__main__":
    success = main()
    exit(0 if success else 1)
```

## æ¤œè¨¼é …ç›®

- [ ] æœ¬ç•ªç’°å¢ƒBLEAã‚¹ã‚¿ãƒƒã‚¯ãŒæ­£å¸¸ã«ãƒ‡ãƒ—ãƒ­ã‚¤ã•ã‚Œã‚‹
- [ ] æœ¬ç•ªãƒ¬ãƒ™ãƒ«ã®ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£è¨­å®šãŒé©ç”¨ã•ã‚Œã‚‹
- [ ] ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆãŒå®Ÿè¡Œã•ã‚Œã‚‹
- [ ] è² è·ãƒ†ã‚¹ãƒˆã§ç›®æ¨™æ€§èƒ½ã‚’é”æˆã™ã‚‹
- [ ] ç›£è¦–ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰ãŒæ©Ÿèƒ½ã™ã‚‹
- [ ] ã‚¢ãƒ©ãƒ¼ãƒˆã‚·ã‚¹ãƒ†ãƒ ãŒå‹•ä½œã™ã‚‹
- [ ] ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—æ©Ÿèƒ½ãŒå‹•ä½œã™ã‚‹
- [ ] ç½å®³å¾©æ—§æ©Ÿèƒ½ãŒç¢ºèªã•ã‚Œã‚‹
- [ ] SSLè¨¼æ˜æ›¸ãŒæ­£ã—ãè¨­å®šã•ã‚Œã‚‹
- [ ] CDNé…ä¿¡ãŒæœ€é©åŒ–ã•ã‚Œã¦ã„ã‚‹

## ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ç›®æ¨™

- [ ] API ãƒ¬ã‚¹ãƒãƒ³ã‚¹æ™‚é–“: å¹³å‡ < 500ms
- [ ] P95 ãƒ¬ã‚¹ãƒãƒ³ã‚¹æ™‚é–“: < 1ç§’
- [ ] åŒæ™‚æ¥ç¶šãƒ¦ãƒ¼ã‚¶ãƒ¼æ•°: 1000ãƒ¦ãƒ¼ã‚¶ãƒ¼
- [ ] ã‚¹ãƒ«ãƒ¼ãƒ—ãƒƒãƒˆ: 10,000 req/min
- [ ] å¯ç”¨æ€§: 99.9% ä»¥ä¸Š
- [ ] ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ãƒ¬ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³é…å»¶: < 1ç§’

## æ¬¡ã®ã‚¿ã‚¹ã‚¯ã¸ã®å¼•ãç¶™ãäº‹é …

- æœ¬ç•ªç’°å¢ƒè¨­å®šè©³ç´°
- ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆçµæœ
- æœ€é©åŒ–å®Ÿæ–½çŠ¶æ³
- ç›£è¦–ãƒ»ã‚¢ãƒ©ãƒ¼ãƒˆè¨­å®šå®Œäº†çŠ¶æ³

## å‚è€ƒè³‡æ–™

- [AWS Well-Architected Performance Efficiency](https://docs.aws.amazon.com/wellarchitected/latest/performance-efficiency-pillar/)
- [Aurora Performance Best Practices](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/Aurora.BestPractices.html)
- [CloudFront Performance Optimization](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/optimization.html)